#version 430 core

// ## Workgroup layout (just linear of atoms)
layout(local_size_x = 8, local_size_y = 1, local_size_z = 1) in;

// ## Constant values
const int neighborsMaxCount = 10;

// ## Global variables
int cuttingFaceCount = 0;
vec3 cuttingFaceCenters[neighborsMaxCount];
float cuttingFaceRadii[neighborsMaxCount];
vec3 cuttingFaceNormals[neighborsMaxCount];

// ## Uniforms
uniform int atomCount;
uniform float probeRadius;

// ## Structs
struct AtomStruct
{
    vec3 center;
    float radius;
};

// ## SSBOs
layout(std430, binding = 0) readonly restrict buffer AtomBuffer
{
    AtomStruct atoms[];
};

// ## Atomic counter
layout(binding = 1) uniform atomic_uint index;

// ## Image with output indices of surface atoms
layout(binding = 2, r32ui) restrict writeonly uniform uimageBuffer list;

// ## Function to test whether endpoint is NOT cut away
bool testEndpoint(vec3 endpoint)
{
    // Just some reservation
    vec3 vector;

    // Iterate over cuttingFaceIndices entries
    for(int i = 0; i < cuttingFaceCount; i++)
    {
        // Vector from cutting face center to endpoint
        vector = endpoint - cuttingFaceCenters[i];

        // Dot product should have positive sign if in same half space
        if(dot(vector, cuttingFaceNormals[i]) > 0)
        {
            return false;
        }
    }
    return true;
}

// ## Main function
void main()
{
    // Index
    int atomIndex = int(gl_GlobalInvocationID.x);

    // Check whether in range
    if(atomIndex >= atomCount) { return; }

    // One endpoint which survices cutting tests is enough
    bool surfaceAtom = false;

    // ### OWN VALUES ###

    // Own extended radius
    float atomExtRadius = atoms[atomIndex].radius + probeRadius;

    // Own center
    vec3 atomCenter = atoms[atomIndex].center;

    // ### BUILD UP OF CUTTING FACE LIST ###

    // Go over other atoms and build cutting face list
    for(int i = 0; i < atomCount; i++)
    {
        // Do not cut with itself
        if(i == atomIndex) { continue; }

        // ### OTHER'S VALUES ###

        // Get values from other atom
        vec3 otherAtomCenter = atoms[i].center;
        float otherAtomExtRadius = atoms[i].radius + probeRadius;

        // ### INTERSECTION TEST ###

        // Vector from center to other's
        vec3 connection = otherAtomCenter - atomCenter;

        // Distance between atoms
        float atomDistance = length(connection);

        // Do they intersect with extended radii?
        if(atomDistance >= (atomExtRadius + otherAtomExtRadius)) { continue; }

        // NODE: Following cases are NOT considered
        // - both spheres touch each other in one point
        // - one sphere lies completely inside other
        // - one sphere lies completely inside other and touches other's surface in one point

        // ### INTERSECTION ###

        // Squared atom distance
        float atomDistanceSquared = atomDistance * atomDistance;

        // Calculate center of intersection
        // http://gamedev.stackexchange.com/questions/75756/sphere-sphere-intersection-and-circle-sphere-intersection
        float h =
            0.5
            + ((atomExtRadius * atomExtRadius)
            - (otherAtomExtRadius * otherAtomExtRadius))
            / atomDistanceSquared;

        // ### CUTTING FACE LIST ###

        // Use connection between centers as line
        cuttingFaceCenters[cuttingFaceCount] = atomCenter + h * connection;

        // Calculate radius of intersection
        cuttingFaceRadii[cuttingFaceCount] =
            sqrt((atomExtRadius * atomExtRadius)
            - h * h * atomDistanceSquared);

        // Calculate normal of intersection
        cuttingFaceNormals[cuttingFaceCount] = normalize(connection);

        // Increment cutting face list index and break if max count of neighbors reached
        if((++cuttingFaceCount) == neighborsMaxCount) { break; }
    }

    // ### CHECK CUTTING FACES AND INTERSECTION LINE ENDPOINTS ###

    for(int i = 0; i < cuttingFaceCount - 1; i++)
    {
        // Values of cutting face
        vec3 faceCenter = cuttingFaceCenters[i];
        float faceRadius = cuttingFaceRadii[i];
        vec3 faceNormal = cuttingFaceNormals[i];

        // Test every cutting face for intersection line with other
        for(int j = i+1; j < cuttingFaceCount; j++)
        {
            // Values of other cutting face
            vec3 otherFaceCenter = cuttingFaceCenters[j];
            float otherFaceRadius = cuttingFaceRadii[j];
            vec3 otherFaceNormal = cuttingFaceNormals[j];

            // Check for parallelity (just not handle it :D)
            if(faceNormal == otherFaceNormal) { continue; }

            // Intersection of planes, resulting in line
            // http://stackoverflow.com/questions/6408670/line-of-intersection-between-two-planes

            // Direction of line
            vec3 lineDir = cross(faceNormal, otherFaceNormal);

            // No determinant necessary, because check for parallelity already done and normals are unit vectors

            // Point on line
            vec3 linePoint =
                (cross(lineDir, otherFaceNormal) * length(faceCenter)
                + (cross(faceNormal, lineDir) * length(otherFaceCenter)));

            // Intersection of line with sphere, resulting in two, one or no endpoints
            // https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection

            // Calculate the part under the square root
            float underSQRT1 = dot(lineDir, (linePoint - atomCenter));
            underSQRT1 = underSQRT1 * underSQRT1;
            float underSQRT2 = length(linePoint - atomCenter);
            underSQRT2 = underSQRT2 * underSQRT2;
            float underSQRT = underSQRT1 - underSQRT2 + (atomExtRadius * atomExtRadius);

            // Left part of equation
            float left = -(dot(lineDir, (linePoint - atomCenter)));

            // Check value under square root
            if(underSQRT > 0)
            {
                // Right part of equation
                float right = sqrt(underSQRT);

                // First endpoint
                float d = left + right;
                if(testEndpoint(linePoint + d * lineDir))
                {
                    // Break out of for loop (and outer)
                    surfaceAtom = true;
                    break;
                }

                // Second endpoint
                d = left - right;
                if(testEndpoint(linePoint + d * lineDir))
                {
                    // Break out of for loop (and outer)
                    surfaceAtom = true;
                    break;
                }
            }
            else if(underSQRT == 0)
            {
                // Just test the one endpoint
                float d = left;
                if(testEndpoint(linePoint + d * lineDir))
                {
                    // Break out of for loop (and outer)
                    surfaceAtom = true;
                    break;
                }
            }
            else
            {
                // No intersection line for those two cutting faces

                // Connection between faces' center
                vec3 connection = otherFaceCenter - faceCenter;

                // Test connection with normals
                if(dot(faceNormal, connection) > 0 && dot(otherFaceNormal, connection) < 0)
                {
                    // No surface atom since cut away by the two cutting faces
                    return;
                }

                // TODO: Cases Figure 4 b and c. Does not create endpoints but is not internal...
            }
        }
    }

    // ### ATOM IS SURFACE ATOM ###

    // When there was no cut it is also a surface atom
    if(surfaceAtom || cuttingFaceCount == 0)
    {
        // Increment atomic counter
        uint idx = atomicCounterIncrement(index);

        // Save index of atom at index of atomic counter in image
        imageStore(list, int(idx), uvec4(gl_GlobalInvocationID.x));
    }
};
