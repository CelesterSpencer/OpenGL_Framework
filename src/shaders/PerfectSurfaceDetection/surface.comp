#version 430 core

// Workgroup layout (just linear of atoms)
layout(local_size_x=8, local_size_y=1, local_size_z=1) in;

// Constant values
const int neighborsMaxCount = 8;

// Global variables
int cuttingFaceCount = 0;
vec3 cuttingFaceCenters[neighborsMaxCount];
float cuttingFaceRadii[neighborsMaxCount];
vec3 cuttingFaceNormals[neighborsMaxCount];

// Uniforms
uniform int atomCount;
uniform float probeRadius;

// Structs
struct AtomStruct
{
    vec3 center;
    float radius;
};

// SSBOs
layout(std430, binding = 0) readonly restrict buffer AtomBuffer
{
    AtomStruct atoms[];
};

// Atomic counter
layout(binding = 1) uniform atomic_uint index;

// Image with output indices of surface atoms
layout(binding = 2, r32ui) restrict writeonly uniform uimageBuffer list;

// Function to test whether endpoint is NOT cut away
bool testEndpoint(vec3 endPoint)
{
    for(int c = 0; c < cuttingFaceCount; c++)
    {
        vec3 vector = cuttingFaceCenters[c] - endPoint;
        if(dot(vector, cuttingFaceNormals[c]) > 0)
        {
            return false;
        }
    }
    return true;
}

// Main function
void main()
{
    // Index
    int atomIndex = int(gl_GlobalInvocationID.x);

    // Check whether in range
    if(atomIndex < atomCount)
    {
        // ### OWN VALUES ###

        // Own radius
        float atomRadius = atoms[atomIndex].radius + probeRadius;

        // Own center
        vec3 atomCenter = atoms[atomIndex].center;

        // One endpoint which survices cutting tests is enough
        bool surfaceAtom = false;

        // ### ITERATION OVER ALL OTHER ATOMS TO BUILD UP CUTTING FACE LIST ###

        // Go over other atoms and build cutting face list
        for(int a = 0; a < atomCount; a++)
        {
            if(a == atomIndex) { continue; }

            // ### OTHER'S VALUES ###

            // Get values from other atom
            vec3 otheratomCenter = atoms[a].center;
            float otherAtomRadius = atoms[a].radius + probeRadius;

            // ### INTERSECTION TEST ###

            // Vector from one center to other
            vec3 connection = otheratomCenter - atomCenter;

            // Distance between extended atoms
            float atomDistance = length(connection);

            // Do they intersect? (TODO: think about equal..just add endpoint directly?)
            if(atomDistance >= (atomRadius + otherAtomRadius))
            {
                continue;
            }

            // ### INTERSECTION AND CUTTING FACE LIST ###

            // Calculate center of intersection
            // http://gamedev.stackexchange.com/questions/75756/sphere-sphere-intersection-and-circle-sphere-intersection
            float h = 0.5 + ((atomRadius * atomRadius) - (otherAtomRadius * otherAtomRadius)) / (atomDistance * atomDistance);
            cuttingFaceCenters[cuttingFaceCount] = atomCenter + h * connection;

            // Calculate radius of intersection
            cuttingFaceRadii[cuttingFaceCount] = sqrt((atomRadius * atomRadius) - h * h* atomDistance * atomDistance);

            // Calculate normal of intersection
            cuttingFaceNormals[cuttingFaceCount] = normalize(connection);

            // Increment cutting face list index and break if max count of neighbors reached
            if((++cuttingFaceCount) == neighborsMaxCount)
            {
                break;
            }
        }

        // ### ITERATION OVER ALL CUTTING FACES TO BUILD END POINTS ###

        for(int c = 0; c < cuttingFaceCount - 1; c++)
        {
            // Values of cutting face
            vec3 faceCenter = cuttingFaceCenters[c];
            float faceRadius = cuttingFaceRadii[c];
            vec3 faceNormal = cuttingFaceNormals[c];

            // Test every cutting face for intersection line with other
            for(int d = c+1; d < cuttingFaceCount; d++)
            {
                // Values of other cutting face
                vec3 otherFaceCenter = cuttingFaceCenters[d];
                float otherFaceRadius = cuttingFaceRadii[d];
                vec3 otherFaceNormal = cuttingFaceNormals[d];

                // Check for parallel (just not handle it :D)
                if(faceNormal == otherFaceNormal) { continue; }

                // Intersection of planes, resulting in line
                // http://stackoverflow.com/questions/6408670/line-of-intersection-between-two-planes

                // Direction of line
                vec3 lineDir = cross(faceNormal, otherFaceNormal);

                // Determinant (should be not zero since already check for parallelity)
                float lineDet = sqrt(length(lineDir));

                // Point on line
                vec3 linePoint =
                    (cross(lineDir, otherFaceNormal) * length(faceCenter)
                    + (cross(faceNormal, lineDir) * length(otherFaceCenter)))
                    / lineDet;

                // Intersection of line with sphere, resulting in two, one or no endpoints
                // https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
                float underSQRT1 = dot(lineDir, (linePoint - atomCenter));
                underSQRT1 = underSQRT1 * underSQRT1;
                float underSQRT2 = length(linePoint - atomCenter);
                underSQRT2 = underSQRT2 * underSQRT2;
                float underSQRT = underSQRT1 - underSQRT2 + atomRadius * atomRadius;

                // Left part of equation
                float left = -(dot(lineDir,(linePoint - atomCenter)));

                // Check value under square root
                if(underSQRT > 0)
                {
                    // Right part of equation
                    float right = sqrt(underSQRT);

                    // First endpoint
                    float d = left + right;
                    if(testEndpoint(linePoint + d * lineDir))
                    {
                        // Break out of for loop (and outer)
                        surfaceAtom = true;
                        break;
                    }

                    // Second endpoint
                    d = left - right;
                    if(testEndpoint(linePoint + d * lineDir))
                    {
                        // Break out of for loop (and outer)
                        surfaceAtom = true;
                        break;
                    }
                }
                else if(underSQRT == 0)
                {
                    // Just test the one endpoint
                    float d = left;
                    if(testEndpoint(linePoint + d * lineDir))
                    {
                        // Break out of for loop (and outer)
                        surfaceAtom = true;
                        break;
                    }
                }
            }
        }

        // ### ATOM IS SURFACE ATOM ###

        // When there was no cut it is also a surface atom
        if(surfaceAtom || cuttingFaceCount == 0)
        {
            // Increment atomic counter
            uint idx = atomicCounterIncrement(index);

            // Save index of atom at index of atomic counter in image
            imageStore(list, int(idx), uvec4(gl_GlobalInvocationID.x));
        }
    }
};
