#version 430

#define GRID_UNDEF 4294967295

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
// SSBOs
layout(std430, binding = 1) buffer PositionsBuffer   { vec3 pos[];     };
layout(std430, binding = 2) buffer GridcellsBuffer   { uint gcell[];   };
layout(std430, binding = 3) buffer GridindicesBuffer { uint gndx[];    };
layout(std430, binding = 4) buffer GridcountBuffer   { int  gridcnt[]; };

struct Grid {
    vec3  min;
    vec3  delta;
    ivec3 res;
    ivec3 scan;
};

uniform Grid grid;
uniform int pnum;

void main() {
    // get particle index // TODO: check if the calculation is correct
    uint i = gl_GlobalInvocationID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y +
             gl_GlobalInvocationID.y * gl_NumWorkGroups.x +
             gl_GlobalInvocationID.x;
    if (i >= pnum) return;

    // pass grid parameters
    vec3 gridMin   = grid.min;
    vec3 gridDelta = grid.delta;
    ivec3 gridRes  = grid.res;
    ivec3 gridScan = grid.scan;

    int gs;
    vec3 gcf;
    ivec3 gc;

    // determine the corresponding cell from the element position
    gcf = (pos[i] - gridMin) * gridDelta;
    gc = ivec3(gcf.x, gcf.y, gcf.z);
    gs = (gc.y * gridRes.z + gc.z) * gridRes.x + gc.x;
    // element position must be inside the scan reach
    if (gc.x >= 1 && gc.x <= gridScan.x &&
        gc.y >= 1 && gc.y <= gridScan.y &&
        gc.z >= 1 && gc.z <= gridScan.z) {
        // remember the 1D index of the cell the element is in
        gcell[i] = gs;
        /*
         * count elements per grid cell
         * every element remembers at which position it was inserted
         * into the grid
         */
        gndx[i] = atomicAdd(gridcnt[gs], 1);

        // TODO: left out this part since it seems not to be used
        // TODO: check if poff is necessary or can be left out in the whole program
    } else {
        // if element is outside the grid it has no corresponding grid cell
        gcell[i] = GRID_UNDEF;
    }
}
